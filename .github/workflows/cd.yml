# .github/workflows/cd.yml
name: Continuous Deployment (CD)

on:
  push:
    branches: [main]
  workflow_dispatch:  # Allow manual trigger

jobs:
  # Run all CI checks first
  ci-checks:
    name: Run CI Checks
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: "npm"
          cache-dependency-path: "backend/package-lock.json"

      - name: Install dependencies
        working-directory: backend
        run: npm ci

      - name: Run linter
        working-directory: backend
        run: npm run lint

      - name: Run tests
        working-directory: backend
        run: npm test
        env:
          NODE_ENV: test
          MONGODB_URI: ${{ secrets.TEST_MONGODB_URI }}

  # Security scanning
  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    needs: ci-checks
    steps:
      - uses: actions/checkout@v4

      # Set up Docker Buildx
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # Container scanning with Trivy
      - name: Build Docker image for scanning
        uses: docker/build-push-action@v5
        with:
          context: .
          push: false
          tags: momo-splitwise-backend:latest
          load: true
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Scan Docker image for vulnerabilities
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: "momo-splitwise-backend:latest"
          format: "table"
          exit-code: "1"
          ignore-unfixed: true
          severity: "CRITICAL"
          scan-type: "image"

      # IaC scanning with tfsec
      - name: Run tfsec
        uses: aquasecurity/tfsec-action@v1.0.0
        with:
          working_directory: terraform
          soft_fail: true

  # Build and push to Azure Container Registry
  build-and-push:
    name: Build and Push to ACR
    runs-on: ubuntu-latest
    needs: security-scan
    steps:
      - uses: actions/checkout@v4

      # Set up Docker Buildx
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get ACR details from Terraform
        id: get-acr
        working-directory: terraform
        run: |
          terraform init -backend=false
          ACR_NAME=$(terraform output -raw container_registry_name 2>/dev/null || echo "${{ secrets.ACR_NAME }}")
          ACR_LOGIN_SERVER=$(terraform output -raw container_registry_login_server 2>/dev/null || echo "${{ secrets.ACR_LOGIN_SERVER }}")
          echo "acr_name=$ACR_NAME" >> $GITHUB_OUTPUT
          echo "acr_login_server=$ACR_LOGIN_SERVER" >> $GITHUB_OUTPUT
        continue-on-error: true

      - name: Set ACR variables
        id: acr-vars
        run: |
          ACR_NAME="${{ secrets.ACR_NAME }}"
          ACR_LOGIN_SERVER="${{ secrets.ACR_LOGIN_SERVER }}"
          if [ -z "$ACR_NAME" ]; then
            ACR_NAME="${{ steps.get-acr.outputs.acr_name }}"
          fi
          if [ -z "$ACR_LOGIN_SERVER" ]; then
            ACR_LOGIN_SERVER="${{ steps.get-acr.outputs.acr_login_server }}"
          fi
          if [ -z "$ACR_NAME" ] || [ -z "$ACR_LOGIN_SERVER" ]; then
            echo "âŒ ACR_NAME and ACR_LOGIN_SERVER must be set in GitHub secrets"
            exit 1
          fi
          echo "acr_name=$ACR_NAME" >> $GITHUB_OUTPUT
          echo "acr_login_server=$ACR_LOGIN_SERVER" >> $GITHUB_OUTPUT
          echo "image_tag=${ACR_LOGIN_SERVER}/momo-splitwise-backend:${GITHUB_SHA::8}" >> $GITHUB_OUTPUT
          echo "image_tag_latest=${ACR_LOGIN_SERVER}/momo-splitwise-backend:latest" >> $GITHUB_OUTPUT

      - name: Login to Azure Container Registry
        run: |
          az acr login --name ${{ steps.acr-vars.outputs.acr_name }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ${{ steps.acr-vars.outputs.image_tag }}
            ${{ steps.acr-vars.outputs.image_tag_latest }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Output image details
        run: |
          echo "âœ… Image pushed successfully:"
          echo "  - ${{ steps.acr-vars.outputs.image_tag }}"
          echo "  - ${{ steps.acr-vars.outputs.image_tag_latest }}"

  # Deploy to Azure VM using Ansible
  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: build-and-push
    environment: production
    steps:
      - uses: actions/checkout@v4

      - name: Set up SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.APPLICATION_VM_IP }} >> ~/.ssh/known_hosts || true

      - name: Get ACR details
        id: acr-details
        run: |
          ACR_NAME="${{ secrets.ACR_NAME }}"
          ACR_LOGIN_SERVER="${{ secrets.ACR_LOGIN_SERVER }}"
          if [ -z "$ACR_NAME" ] || [ -z "$ACR_LOGIN_SERVER" ]; then
            echo "âŒ ACR_NAME and ACR_LOGIN_SERVER must be set in GitHub secrets"
            exit 1
          fi
          echo "acr_name=$ACR_NAME" >> $GITHUB_OUTPUT
          echo "acr_login_server=$ACR_LOGIN_SERVER" >> $GITHUB_OUTPUT
          echo "image_tag=${ACR_LOGIN_SERVER}/momo-splitwise-backend:${GITHUB_SHA::8}" >> $GITHUB_OUTPUT
          echo "image_tag_latest=${ACR_LOGIN_SERVER}/momo-splitwise-backend:latest" >> $GITHUB_OUTPUT

      - name: Install Ansible
        run: |
          sudo apt-get update
          sudo apt-get install -y ansible

      - name: Create Ansible inventory
        run: |
          mkdir -p ansible/inventory
          cat > ansible/inventory/production.yml <<EOF
          all:
            children:
              application:
                hosts:
                  application_vm:
                    ansible_host: ${{ secrets.APPLICATION_VM_IP }}
                    ansible_user: azureuser
                    ansible_ssh_private_key_file: ~/.ssh/id_rsa
                    ansible_ssh_common_args: '-o StrictHostKeyChecking=no'
            vars:
              ansible_python_interpreter: /usr/bin/python3
              ansible_connection: ssh
          EOF

      - name: Create Ansible group vars
        run: |
          mkdir -p ansible/group_vars
          cat > ansible/group_vars/application.yml <<EOF
          ---
          acr_name: ${{ steps.acr-details.outputs.acr_name }}
          acr_resource_group: ${{ secrets.ACR_RESOURCE_GROUP }}
          acr_login_server: ${{ steps.acr-details.outputs.acr_login_server }}
          image_tag: ${{ steps.acr-details.outputs.image_tag_latest }}
          app_name: momo-splitwise
          app_environment: prod
          docker_compose_version: "2.24.0"
          docker_users:
            - azureuser
          EOF

      - name: Run Ansible deployment playbook
        working-directory: ansible
        run: |
          ansible-playbook \
            -i inventory/production.yml \
            playbooks/deploy.yml \
            --extra-vars "image_tag=${{ steps.acr-details.outputs.image_tag_latest }}"

      - name: Verify deployment
        run: |
          echo "âœ… Deployment completed!"
          echo "Application Gateway URL: ${{ secrets.APPLICATION_GATEWAY_URL }}"
          echo "Health check endpoints:"
          echo "  - ${{ secrets.APPLICATION_GATEWAY_URL }}/health"
          echo "  - ${{ secrets.APPLICATION_GATEWAY_URL }}/api/health"
          
      - name: Health check verification
        run: |
          GATEWAY_URL="${{ secrets.APPLICATION_GATEWAY_URL }}"
          if [ -z "$GATEWAY_URL" ]; then
            echo "âš ï¸ APPLICATION_GATEWAY_URL secret not set, skipping health check"
            exit 0
          fi
          
          echo "ðŸ” Checking health endpoint..."
          MAX_RETRIES=10
          RETRY_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 "${GATEWAY_URL}/health" || echo "000")
            
            if [ "$HTTP_CODE" = "200" ]; then
              echo "âœ… Health check passed! Application is responding."
              curl -s "${GATEWAY_URL}/health" | jq '.' || echo "Response received (non-JSON)"
              exit 0
            fi
            
            RETRY_COUNT=$((RETRY_COUNT + 1))
            echo "â³ Health check attempt $RETRY_COUNT/$MAX_RETRIES failed (HTTP $HTTP_CODE). Retrying in 15 seconds..."
            sleep 15
          done
          
          echo "âŒ Health check failed after $MAX_RETRIES attempts"
          echo "âš ï¸ Deployment may have succeeded but health check is failing. Please verify manually."
          exit 0  # Don't fail the workflow, just warn
